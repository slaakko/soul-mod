// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module otava.parser.templates;

[interface]import otava.symbols.context;
[interface]import otava.ast;
[implementation]import soul.ast.source.pos;
[implementation]import soul.ast.lexer.pos.pair;
[implementation]import otava.token;
[implementation]import otava.lexer;
[implementation]import otava.symbols;
[implementation]import otava.parser.concepts;
[implementation]import otava.parser.declaration;
[implementation]import otava.parser.function;
[implementation]import otava.parser.expression;
[implementation]import otava.parser.identifier;
[implementation]import otava.parser.literal;
[implementation]import otava.parser.punctuation;
[implementation]import otava.parser.type;

parser TemplateParser
{
    lexer otava::lexer::OtavaLexer<char32_t>;

    using ConceptParser.ConceptDefinition;
    using ConceptParser.RequiresClause;
    using ConceptParser.TypeConstraint;
    using DeclarationParser.Declaration;
    using DeclarationParser.ExplicitSpecifier;
    using ExpressionParser.ConstantExpression;
    using ExpressionParser.IdExpression;
    using FunctionParser.OperatorFunctionId;
    using FunctionParser.ParameterDeclaration;
    using FunctionParser.ParameterDeclarationClause;
    using IdentifierParser.Identifier;
    using LiteralParser.LiteralOperatorId;
    using PunctuationParser.Assign;
    using PunctuationParser.Comma;
    using PunctuationParser.Ellipsis;
    using PunctuationParser.Semicolon;
    using TypeParser.TypeId;

    TemplateDeclaration(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> templateHeadNode, 
        var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= TemplateHead(context, true):templateHead
            { 
                templateHeadNode.reset(templateHead); 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            (   ConceptDefinition(context):concepDefinition
                { 
                    auto rv = otava::symbols::EndTemplateDeclaration(templateHeadNode.get(), context); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    return new otava::ast::TemplateDeclarationNode(sourcePos, templateHeadNode.release(), concepDefinition); 
                }
            |   Declaration(context):declaration
                { 
                    auto rv = otava::symbols::EndTemplateDeclaration(templateHeadNode.get(), context); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    return new otava::ast::TemplateDeclarationNode(sourcePos, templateHeadNode.release(), declaration); 
                }
            |   empty
                { 
                    auto rv = otava::symbols::RemoveTemplateDeclaration(context); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    pass = false; 
                }
            )
        ;

    TemplateHead(otava::symbols::Context* context, bool begin, var soul::ast::SourcePos sourcePos, var std::unique_ptr<otava::ast::TemplateHeadNode> templateHeadNode) : 
        otava::ast::Node*
        ::= 
        (
            TEMPLATE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
                templateHeadNode.reset(new otava::ast::TemplateHeadNode(sourcePos)); 
                if (begin) 
                {
                    auto rv = otava::symbols::BeginTemplateDeclaration(templateHeadNode.get(), context); 
                    if (!rv) return std::unexpected<int>(rv.error());
                }
            }
            TemplateParameterList(context):templateParamList{ templateHeadNode->SetTemplateParameterList(templateParamList); }
            (
                RequiresClause(context):requiresClause
                { 
                    templateHeadNode->SetRequiresClause(requiresClause); 
                }
            )?
        )
        {
            return templateHeadNode.release();
        }
        ;

    TemplateParameterList(otava::symbols::Context* context, var int index, var std::unique_ptr<otava::ast::Node> templateParameterNode, 
        var std::unique_ptr<otava::ast::TemplateParameterListNode> node, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : otava::ast::Node*
        ::= 
        (
            LANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                soul::ast::SourcePos sourcePos = *sp;
                node.reset(new otava::ast::TemplateParameterListNode(sourcePos)); 
                laPos = sourcePos; 
            } 
            TemplateParameter(context):first
            { 
                templateParameterNode.reset(first); 
                auto rv = otava::symbols::AddTemplateParameter(templateParameterNode.get(), index, context); 
                if (!rv) return std::unexpected<int>(rv.error());
                rv = node->AddNode(templateParameterNode.release()); 
                if (!rv) return std::unexpected<int>(rv.error());
                index = index + 1; 
            } 
            (
                Comma:comma
                { 
                    auto rv = node->AddNode(comma); 
                    if (!rv) return std::unexpected<int>(rv.error());
                } 
                TemplateParameter(context):next
                { 
                    templateParameterNode.reset(next); 
                    auto rv = otava::symbols::AddTemplateParameter(templateParameterNode.get(), index, context); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    rv = node->AddNode(templateParameterNode.release()); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    index = index + 1; 
                }
            )*
            RANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                raPos = *sp;
            }
        )
        {
            node->SetLAnglePos(laPos);
            node->SetRAnglePos(raPos);
            return node.release();
        }
        ;

    TemplateParameter(otava::symbols::Context* context) : otava::ast::Node*
        ::= TypeParameter(context):typeParam{ return typeParam; }
        |   ParameterDeclaration(context):param{ return param; }
        ;

    TypeParameter(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos, 
        var std::unique_ptr<otava::ast::Node> ellipsisNode, var std::unique_ptr<otava::ast::Node> identifierNode) : otava::ast::Node*
        ::= (
                TemplateHead(context, false):templateHead
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp;
                }
            )?
            (   TypeParameterKey:key
                { 
                    if (!sourcePos.IsValid()) 
                    {
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp;
                    }
                }
                (   Identifier(context):id 
                    Assign:asgn 
                    (   IdExpression(context):idExpr{ return new otava::ast::TypeParameterNode(sourcePos, key, id, asgn, idExpr, nullptr, templateHead); }
                    |   TypeId(context):typeId{ return new otava::ast::TypeParameterNode(sourcePos, key, id, asgn, typeId, nullptr, templateHead); }
                    )
                |   (
                        Ellipsis:ellipsis? 
                        Identifier(context):id2?
                    )
                    {
                        ellipsisNode.reset(ellipsis);
                        identifierNode.reset(id2);
                        if (!ellipsisNode && !identifierNode)
                        {
                            pass = false;
                        }
                        else
                        {
                            return new otava::ast::TypeParameterNode(sourcePos, key, identifierNode.release(), nullptr, nullptr, ellipsisNode.release(), templateHead); 
                        }
                    }
                )
            |   TypeConstraint(context):constraint
                { 
                    if (!sourcePos.IsValid()) 
                    {
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp; 
                    }
                }
                (   Identifier(context):id3 
                    Assign:asgn2 
                    TypeId(context):typeId2{ return new otava::ast::TypeParameterNode(sourcePos, constraint, id3, asgn2, typeId2, nullptr, templateHead); }
                |   (
                        Ellipsis:ellipsis2? 
                        Identifier(context):id4?
                    )
                    {
                        ellipsisNode.reset(ellipsis2);
                        identifierNode.reset(id4);
                        if (!ellipsisNode && !identifierNode)
                        {
                            pass = false;
                        }
                        else
                        {
                            return new otava::ast::TypeParameterNode(sourcePos, constraint, identifierNode.release(), nullptr, nullptr, ellipsisNode.release(), templateHead); 
                        }
                    }
                )
            )
        ;

    TypeParameterKey : otava::ast::Node*
        ::= Typename:typename_{ return typename_; }
        |   Class:cls{ return cls; }
        ;

    Typename : otava::ast::Node*
        ::= TYPENAME
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                return new otava::ast::TypenameNode(*sp); 
            }
        ;

    Class : otava::ast::Node*
        ::= CLASS
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                return new otava::ast::ClassNode(*sp); 
            }
        ;

    TemplateId(otava::symbols::Context* context, var std::unique_ptr<otava::ast::TemplateIdNode> node, var std::unique_ptr<otava::ast::Node> templateName, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : otava::ast::Node*
        ::= 
        (
            (
                (   OperatorFunctionId(context):operatorFunctionId
                    { 
                        templateName.reset(operatorFunctionId); 
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp;
                    }
                |   LiteralOperatorId(context):literalOperatorId
                    { 
                        templateName.reset(literalOperatorId); 
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp; 
                    }
                )
                LANGLE
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    laPos = *sp; 
                    ++vars->langleCount; 
                    context->PushSetFlag(otava::symbols::ContextFlags::parsingTemplateId); 
                    node.reset(new otava::ast::TemplateIdNode(sourcePos, templateName.release())); 
                }
                TemplateArgumentList(context, node.get()):templateArgs?
                RANGLE
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    raPos = *sp; 
                    --vars->langleCount; 
                    context->PopFlags(); 
                }
                / 
                { 
                    --vars->langleCount; 
                    context->PopFlags(); 
                }
            )
            {
                node->SetLAnglePos(laPos);
                node->SetRAnglePos(raPos);
                return node.release();
            }
        )
        |   SimpleTemplateId(context):simpleTemplateId{ return simpleTemplateId; }
        ;

    SimpleTemplateId(otava::symbols::Context* context, var std::unique_ptr<otava::ast::TemplateIdNode> node, var soul::ast::SourcePos sourcePos, 
        var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : otava::ast::Node*
        ::= 
        (
            TemplateName(context):templateName
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
            }
            LANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                laPos = *sp; 
                ++vars->langleCount; 
                context->PushSetFlag(otava::symbols::ContextFlags::parsingTemplateId); 
                context->ResetRejectTemplateId();
                node.reset(new otava::ast::TemplateIdNode(sourcePos, templateName)); 
            }
            TemplateArgumentList(context, node.get()):templateArgs?
            RANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                raPos = *sp; 
                --vars->langleCount; 
                context->PopFlags(); 
            }
            / 
            { 
                --vars->langleCount; 
                context->PopFlags(); 
            }
        )
        {
            if (context->RejectTemplateId())
            {
                pass = false;
            }
            else
            {
                node->SetLAnglePos(laPos);
                node->SetRAnglePos(raPos);
                return node.release();
            }
        }
        ;

    TemplateName(otava::symbols::Context* context) : otava::ast::Node*
        ::= Identifier(context):identifier{ return identifier; }
        ;

    TemplateArgumentList(otava::symbols::Context* context, otava::ast::Node* templateIdNode, var int index)
        ::= 
        (
            TemplateArgument(context, templateIdNode, index):left
            { 
                auto rv = templateIdNode->AddNode(left); 
                if (!rv) return std::unexpected<int>(rv.error());
                ++index; 
            }
            (
                Comma:comma
                { 
                    auto rv = templateIdNode->AddNode(comma); 
                    if (!rv) return std::unexpected<int>(rv.error());
                } 
                TemplateArgument(context, templateIdNode, index):right
                { 
                    auto rv = templateIdNode->AddNode(right); 
                    if (!rv) return std::unexpected<int>(rv.error());
                    ++index; 
                }
            )*
        )
        (
            ELLIPSIS
            {
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                auto rv = templateIdNode->AddNode(new otava::ast::EllipsisNode(*sp)); 
                if (!rv) return std::unexpected<int>(rv.error());
            }
        )?
        ;

    TemplateArgument(otava::symbols::Context* context, otava::ast::Node* templateIdNode, int index) : otava::ast::Node*
        ::= empty{ pass = otava::symbols::TemplateArgCanBeTypeId(templateIdNode, index); } 
            TypeId(context):typeId 
            TemplateArgNext:next
            { 
                return typeId; 
            }
        |   ConstantExpression(context):constantExpr{ return constantExpr; }
        |   IdExpression(context):idExpr{ return idExpr; }
        ;

    TemplateArgNext
        ::= &(RANGLE | COMMA | ELLIPSIS)
        ;

    DeductionGuide(otava::symbols::Context* context, var std::unique_ptr<otava::ast::ParameterListNode> params, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos lpPos, var soul::ast::SourcePos rpPos) : otava::ast::Node*
        ::= 
        (
            (
                ExplicitSpecifier(context):explicitSpecifier
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp; 
                }
            )?
            TemplateName(context):templateName
            { 
                if (!sourcePos.IsValid()) 
                {
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp; 
                }
            }
            LPAREN
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                lpPos = *sp; 
                params.reset(new otava::ast::ParameterListNode(lpPos)); 
            }
            ParameterDeclarationClause(context, params.get()):paramDeclarationClause
            RPAREN
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                rpPos = *sp; 
            }
            Arrow:arrow 
            SimpleTemplateId(context):templateId
            Semicolon:semicolon
        )
        {
            return new otava::ast::DeductionGuideNode(sourcePos, templateName, params.release(), arrow, templateId, explicitSpecifier, semicolon, lpPos, rpPos);
        }
        ;

    Arrow : otava::ast::Node*
        ::= ARROW
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                return new otava::ast::ArrowNode(*sp); 
            }
        ;

    ExplicitInstantiation(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            (
                Extern:extrn
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = 
                    *sp; 
                }
            )? 
            Template:tmp
            { 
                if (!sourcePos.IsValid()) 
                {
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp; 
                }
            }
            Declaration(context):declaration
        )
        {
            otava::ast::ExplicitInstantiationNode* node = new otava::ast::ExplicitInstantiationNode(sourcePos, extrn, tmp, declaration);
            auto rv = otava::symbols::ProcessExplicitInstantiation(node, context);
            if (!rv) return std::unexpected<int>(rv.error());
            return node;
        }
        ;

    ExplicitSpecialization(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos,
        var std::unique_ptr<otava::ast::TemplateHeadNode> templateHeadNode) : 
        otava::ast::Node*
        ::= 
        (
            Template:tmp
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
            }
            LANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                laPos = *sp; 
            }
            RANGLE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                raPos = *sp; 
            }
            empty
            {
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                templateHeadNode.reset(new otava::ast::TemplateHeadNode(*sp));
                auto rv = otava::symbols::BeginTemplateDeclaration(templateHeadNode.get(), context); 
                if (!rv) return std::unexpected<int>(rv.error());
                context->PushSetFlag(otava::symbols::ContextFlags::parsingTemplateDeclaration); 
            }
            Declaration(context):declaration{ context->PopFlags(); } 
            / 
            { 
                auto rv = otava::symbols::EndTemplateDeclaration(templateHeadNode.get(), context); 
                if (!rv) return std::unexpected<int>(rv.error());
                context->PopFlags(); 
            }
        )
        {
            auto rv = otava::symbols::EndTemplateDeclaration(templateHeadNode.get(), context); 
            if (!rv) return std::unexpected<int>(rv.error());
            return new otava::ast::ExplicitSpecializationNode(sourcePos, tmp, templateHeadNode.release(), declaration, laPos, raPos);
        }
        ;

    Extern : otava::ast::Node*
        ::= EXTERN
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                return new otava::ast::ExternNode(*sp); 
            }
        ;

    Template : otava::ast::Node*
        ::= TEMPLATE
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                return new otava::ast::TemplateNode(*sp); 
            }
        ;
}
