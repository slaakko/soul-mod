// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module otava.parser.modules;

[interface]import otava.symbols.context;
[implementation]import soul.ast.source.pos;
[implementation]import otava.ast;
[implementation]import otava.token;
[implementation]import otava.lexer;
[implementation]import otava.parser.attribute;
[implementation]import otava.parser.classes;
[implementation]import otava.parser.declaration;
[implementation]import otava.parser.identifier;
[implementation]import otava.parser.punctuation;

parser ModuleParser
{
    lexer otava::lexer::OtavaLexer<char32_t>;

    using AttributeParser.AttributeSpecifierSeq;
    using ClassParser.Private;
    using DeclarationParser.DeclarationSeq;
    using DeclarationParser.Declaration;
    using IdentifierParser.Identifier;
    using PunctuationParser.Colon;
    using PunctuationParser.Semicolon;

    ModuleDeclaration(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            (
                ExportKeyword(context):exportKw
                { 
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp;
                }
            )? 
            ModuleKeyword(context):moduleKw
            { 
                if (!sourcePos.IsValid()) 
                {
                    auto sp = lexer.GetSourcePos(pos); 
                    if (!sp) return std::unexpected<int>(sp.error());
                    sourcePos = *sp;
                }
            }
            ModuleName:moduleName 
            ModulePartition(context):modulePartition? 
            AttributeSpecifierSeq(context):attributes? 
            Semicolon:semicolon
        )
        {
            return new otava::ast::ModuleDeclarationNode(sourcePos, exportKw, moduleKw, moduleName, modulePartition, attributes, semicolon);
        }
        ;

    ModuleName(var std::u32string moduleNameStr, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            ID
            { 
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                moduleNameStr = token->ToString(); 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            (
                DOT ID
                { 
                    auto t = lexer.GetToken(pos);
                    if (!t) return std::unexpected<int>(t.error());
                    const auto* token = *t;
                    moduleNameStr.append(1, '.').append(token->ToString()); 
                }
            )*
        )
        {
            return new otava::ast::ModuleNameNode(sourcePos, moduleNameStr);
        }
        ;

    ExportDeclaration(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> node, var soul::ast::SourcePos sourcePos,
        var soul::ast::SourcePos lbPos, var soul::ast::SourcePos rbPos) : otava::ast::Node*
        ::= 
        (
            ExportKeyword(context):exprt
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            (
                (
                    LBRACE
                    { 
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        lbPos = *sp;
                    }
                    DeclarationSeq(context):declarations?
                    RBRACE
                    { 
                        auto sp = lexer.GetSourcePos(pos); 
                        if (!sp) return std::unexpected<int>(sp.error());
                        rbPos = *sp;
                    }
                )
                {
                    node.reset(new otava::ast::ExportDeclarationNode(sourcePos, exprt, declarations, lbPos, rbPos));
                }
            |   ImportDeclaration(context):imprt
                {
                    node.reset(new otava::ast::ExportDeclarationNode(sourcePos, exprt, imprt, soul::ast::SourcePos(), soul::ast::SourcePos()));
                }
            |   Declaration(context):declaration
                {
                    node.reset(new otava::ast::ExportDeclarationNode(sourcePos, exprt, declaration, soul::ast::SourcePos(), soul::ast::SourcePos()));
                }
            )
            {
                return node.release();
            }
        )
        ;

    ImportDeclaration(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<otava::ast::Node> subject) : otava::ast::Node*
        ::= 
        (
            ImportKeyword(context):imprt
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            (   ModuleName:moduleName{ subject.reset(moduleName); }
            |   ModulePartition(context):modulePartition{ subject.reset(modulePartition); }
            |   HeaderName(context):headerName{ subject.reset(headerName); }
            )
            AttributeSpecifierSeq(context):attributes? 
            Semicolon:semicolon
        )
        {
            return new otava::ast::ImportDeclarationNode(sourcePos, imprt, subject.release(), attributes, semicolon);
        }
        ;

    ModulePartition(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            Colon:colon
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            ModuleName:moduleName
        )
        {
            return new otava::ast::ModulePartitionNode(sourcePos, moduleName);
        }
        ;    

    ExportKeyword(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            Identifier(context):identifier
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                pass = token->ToString() == U"export"; 
            }
        )
        {
            return new otava::ast::ExportNode(sourcePos);
        }
        ;

    ImportKeyword(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            Identifier(context):identifier
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                pass = token->ToString() == U"import"; 
            }
        )
        {
            return new otava::ast::ImportNode(sourcePos);
        }
        ;

    ModuleKeyword(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            Identifier(context):identifier
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                pass = token->ToString() == U"module"; 
            }
        )
        {
            return new otava::ast::ModuleNode(sourcePos);
        }
        ;

    GlobalModuleFragment(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            ModuleKeyword(context):moduleKw
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            Semicolon:semicolon 
            DeclarationSeq(context):declarations?
        )
        {
            return new otava::ast::GlobalModuleFragmentNode(sourcePos, moduleKw, semicolon, declarations);
        }
        ;

    PrivateModuleFragment(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::=
        (
            ModuleKeyword(context):moduleKw
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            }
            Colon:colon
            Private:privat
            Semicolon:semicolon
            DeclarationSeq(context):declarations?
        )
        {
            return new otava::ast::PrivateModuleFragmentNode(sourcePos, moduleKw, colon, privat, semicolon, declarations);
        }
        ;

    HeaderName(otava::symbols::Context* context) : otava::ast::Node*
        ::= ANGLE_HEADER_NAME
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                return new otava::ast::AngleHeaderName(*sp, token->ToString()); 
            }
        |   QUOTE_HEADER_NAME
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                return new otava::ast::QuoteHeaderName(*sp, token->ToString()); 
            }
        ;

}