// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module otava.parser.concepts;

[interface]import otava.symbols.context;
[interface]import otava.ast;
[implementation]import soul.ast.source.pos;
[implementation]import otava.token;
[implementation]import otava.lexer;
[implementation]import otava.symbols;
[implementation]import otava.parser.type;
[implementation]import otava.parser.expression;
[implementation]import otava.parser.function;
[implementation]import otava.parser.identifier;
[implementation]import otava.parser.punctuation;
[implementation]import otava.parser.templates;

parser ConceptParser
{
    lexer otava::lexer::OtavaLexer<char32_t>;

    using TypeParser.TypeName;
    using ExpressionParser.Expression;
    using ExpressionParser.LogicalOrExpression;
    using ExpressionParser.PrimaryExpression;
    using FunctionParser.Noexcept;
    using FunctionParser.ParameterDeclarationClause;
    using IdentifierParser.Identifier;
    using IdentifierParser.NestedNameSpecifier;
    using PunctuationParser.Assign;
    using PunctuationParser.Semicolon;
    using TemplateParser.TemplateArgumentList;

    ConceptDefinition(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            CONCEPT
            { 
                auto sp = lexer.GetSourcePos(pos); 
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
            } 
            ConceptName(context):conceptName 
            Assign:assign{ context->PushSetFlag(otava::symbols::ContextFlags::parsingConceptDefinition); }
            ConstraintExpression(context):constraintExpr{ context->PopFlags(); } / { context->PopFlags(); }
            Semicolon:semicolon
        )
        {
            otava::ast::ConceptDefinitionNode* conceptDefinitionNode = new otava::ast::ConceptDefinitionNode(sourcePos, conceptName, assign, constraintExpr, semicolon);
            auto rv = otava::symbols::ProcessConcept(conceptDefinitionNode, context);
            if (!rv) return std::unexpected<int>(rv.error());
            return conceptDefinitionNode;
        }
        ;
    
    ConceptName(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> identifierNode) : otava::ast::Node*
        ::= Identifier(context):identifier{ return identifier; }
        ;

    ConceptNameChecked(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> identifierNode) : otava::ast::Node*
        ::= Identifier(context):identifier
            { 
                identifierNode.reset(identifier);
                pass = otava::symbols::IsConceptName(identifierNode.get(), context);
                if (pass)
                {
                    return identifierNode.release(); 
                }
            }
        ;

    ConstraintExpression(otava::symbols::Context* context) : otava::ast::Node*
        ::= LogicalOrExpression(context):logicalOrExpr{ return logicalOrExpr; }
        ;

    RequiresClause(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            REQUIRES
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
            }
            ConstraintLogicalOrExpression(context):orExpr
        )
        {
            return new otava::ast::RequiresClauseNode(sourcePos, orExpr);
        }
        ;

    ConstraintLogicalOrExpression(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> node, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos opPos) : otava::ast::Node*
        ::= 
        (
            ConstraintLogicalAndExpression(context):left
            { 
                node.reset(left); 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp; 
            }
            (
                OR_OR
                { 
                    auto sp = lexer.GetSourcePos(pos);
                    if (!sp) return std::unexpected<int>(sp.error());
                    opPos = *sp; 
                } 
                ConstraintLogicalAndExpression(context):right{ node.reset(new otava::ast::BinaryExprNode(sourcePos, new otava::ast::DisjunctionNode(opPos), node.release(), right)); }
            )*
        )
        {
            return node.release();
        }
        ;

    ConstraintLogicalAndExpression(otava::symbols::Context* context, var std::unique_ptr<otava::ast::Node> node, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos opPos) : otava::ast::Node*
        ::= 
        (
            PrimaryExpression(context):left{ node.reset(left); }
            (
                AMP_AMP
                { 
                    auto sp = lexer.GetSourcePos(pos);
                    if (!sp) return std::unexpected<int>(sp.error());
                    opPos = *sp; 
                } 
                PrimaryExpression(context):right{ node.reset(new otava::ast::BinaryExprNode(sourcePos, new otava::ast::ConjunctionNode(opPos), node.release(), right)); }
            )*
        )
        {
            return node.release();
        }
        ;


    RequiresExpression(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            REQUIRES
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            RequirementParameterList(context):params? RequirementBody(context):body
        )
        {
            return new otava::ast::RequiresExprNode(sourcePos, params, body);
        }
        ;

    RequirementParameterList(otava::symbols::Context* context, var std::unique_ptr<otava::ast::ParameterListNode> node, 
        var soul::ast::SourcePos lpPos, var soul::ast::SourcePos rpPos) : otava::ast::Node*
        ::=
        (
            LPAREN
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                lpPos = *sp;
                node.reset(new otava::ast::ParameterListNode(lpPos)); 
            } 
            ParameterDeclarationClause(context, node.get()):paramDeclClause 
            RPAREN
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                rpPos = *sp;
            }
        )
        {
            node->SetLParenPos(lpPos);
            node->SetRParenPos(rpPos);
            return node.release();
        }
        ;

    RequirementBody(otava::symbols::Context* context, var std::unique_ptr<otava::ast::RequirementBodyNode> node, 
        var soul::ast::SourcePos lbPos, var soul::ast::SourcePos rbPos) : otava::ast::Node*
        ::= 
        (
            LBRACE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                lbPos = *sp;
                node.reset(new otava::ast::RequirementBodyNode(lbPos)); 
            }
            RequirementSeq(context, node.get()):requirementSeq
            RBRACE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                rbPos = *sp;
            }
        )
        {
            node->SetLBracePos(lbPos);
            node->SetRBracePos(rbPos);
            return node.release();
        }
        ;

    RequirementSeq(otava::symbols::Context* context, otava::ast::Node* requirementBody) 
        ::= 
        (
            Requirement(context):requirement
            { 
                auto rv = requirementBody->AddNode(requirement); 
                if (!rv) return std::unexpected<int>(rv.error());
            }
        )+
        ;

    Requirement(otava::symbols::Context* context) : otava::ast::Node*
        ::= NestedRequirement(context):nestedRequirement{ return nestedRequirement; }
        |   TypeRequirement(context):typeRequirement{ return typeRequirement; }
        |   CompoundRequirement(context):compoundRequirement{ return compoundRequirement; }
        |   SimpleRequirement(context):simpleRequirement{ return simpleRequirement; }
        ;

    SimpleRequirement(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= Expression(context):expr
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            Semicolon:semicolon{ return new otava::ast::SimpleRequirementNode(sourcePos, expr, semicolon); }
        ;

    TypeRequirement(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= TYPENAME
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            NestedNameSpecifier(context):nns? 
            empty{ context->PushSetFlag(otava::symbols::ContextFlags::assumeType); }
            TypeName(context):typeName{ context->PopFlags(); } / { context->PopFlags(); }
            Semicolon:semicolon
        { 
            return new otava::ast::TypeRequirementNode(sourcePos, nns, typeName, semicolon); 
        }
        ;

    CompoundRequirement(otava::symbols::Context* context, var soul::ast::SourcePos lbPos, var soul::ast::SourcePos rbPos) : otava::ast::Node*
        ::= 
        (
            LBRACE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                lbPos = *sp;
            }
            Expression(context):expr 
            RBRACE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                rbPos = *sp;
            }
            Noexcept:noexcept_? 
            ReturnTypeRequirement(context):returnTypeRequirement?
            Semicolon:semicolon
        )
        {
            return new otava::ast::CompoundRequirementNode(lbPos, expr, noexcept_, returnTypeRequirement, semicolon, lbPos, rbPos);
        }
        ;

    ReturnTypeRequirement(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            ARROW
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            TypeConstraint(context):typeConstraint
        )
        {
            return new otava::ast::ReturnTypeRequirementNode(sourcePos, typeConstraint);
        }
        ;

    NestedRequirement(otava::symbols::Context* context, var soul::ast::SourcePos sourcePos) : otava::ast::Node*
        ::= 
        (
            REQUIRES
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                sourcePos = *sp;
            } 
            ConstraintExpression(context):constraintExpr Semicolon:semicolon
        )
        {
            return new otava::ast::NestedRequirementNode(sourcePos, constraintExpr, semicolon);
        }
        ;

    TypeConstraint(otava::symbols::Context* context, var std::unique_ptr<otava::ast::TypeConstraintNode> node, var std::unique_ptr<otava::ast::Node> conceptName, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : otava::ast::Node*
        ::= 
        (
            (
                (   NestedNameSpecifier(context):nns
                    { 
                        auto sp = lexer.GetSourcePos(pos);
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp;
                    } 
                    ConceptNameChecked(context):conceptName1{ conceptName.reset(new otava::ast::QualifiedIdNode(sourcePos, nns, conceptName1)); }
                |   ConceptNameChecked(context):conceptName2
                    { 
                        auto sp = lexer.GetSourcePos(pos);
                        if (!sp) return std::unexpected<int>(sp.error());
                        sourcePos = *sp;
                        conceptName.reset(conceptName2); 
                    }
                )
                {
                    node.reset(new otava::ast::TypeConstraintNode(sourcePos, conceptName.release())); 
                }
            )
            (
                LANGLE
                { 
                    auto sp = lexer.GetSourcePos(pos);
                    if (!sp) return std::unexpected<int>(sp.error());
                    laPos = *sp;
                    ++vars->langleCount; 
                    context->PushSetFlag(otava::symbols::ContextFlags::parsingTemplateId); 
                    node->SetHasTemplateArgumentList(); 
                }
                TemplateArgumentList(context, node.get()):templateArgs?
                RANGLE
                { 
                    auto sp = lexer.GetSourcePos(pos);
                    if (!sp) return std::unexpected<int>(sp.error());
                    raPos = *sp;
                    --vars->langleCount; 
                    context->PopFlags(); 
                } / 
                { 
                    --vars->langleCount; 
                    context->PopFlags(); 
                }
            )?
        )
        {
            node->SetLAnglePos(laPos);
            node->SetRAnglePos(raPos);
            return node.release();
        }
    ;
}
