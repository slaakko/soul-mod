// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.re.parser;

[interface]import soul.ast.re;
[implementation]import soul.cpp.token;
[implementation]import soul.cpp.op.token;
[implementation]import soul.punctuation.token;
[implementation]import soul.tool.token;
[implementation]import soul.lex;
[implementation]import soul.re.token.parser;

parser RegExParser
{
    lexer soul::lex::re::RegExLexer<char32_t>;

    main;

    RegularExpression(soul::ast::re::LexerContext* lexerContext) : soul::ast::re::Nfa
        ::= Alternative(lexerContext):alternative{ return alternative; }
        ;

    Alternative(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Nfa value) : soul::ast::re::Nfa
        ::= 
        (
            Catenation(lexerContext):left{ value = left; } 
            (
                PIPE Catenation(lexerContext):right{ value = soul::ast::re::Alt(*lexerContext, value, right); }
            )*
        )
        {
            return value;
        }
        ;

    Catenation(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Nfa value) : soul::ast::re::Nfa
        ::= 
        (
            Repetition(lexerContext):left{ value = left; } 
            (
                Repetition(lexerContext):right{ value = soul::ast::re::Cat(value, right); }
            )*
        )
        {
            return value;
        }
        ;

    Repetition(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Nfa value) : soul::ast::re::Nfa
        ::=
        (   Primary(lexerContext):left{ value = left; }
            (   STAR{ value = soul::ast::re::Kleene(*lexerContext, value); }
            |   PLUS{ value = soul::ast::re::Pos(*lexerContext, value); }
            |   QUEST{ value = soul::ast::re::Opt(*lexerContext, value); }
            )?
        )
        {
            return value;
        }
        ;

    Primary(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Nfa value) : soul::ast::re::Nfa
        ::=
        (   LPAREN 
            Alternative(lexerContext):alt{ value = alt; } 
            RPAREN
        |   ESCAPE
            { 
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                auto rv = soul::re::token::parser::MakeEscapeValue(lexer.FileName(), *t);
                if (!rv) return std::unexpected<int>(rv.error());
                std::expected<soul::ast::re::Symbol*, int> crv = lexerContext->MakeChar(*rv);
                if (!crv) return std::unexpected<int>(crv.error());
                value = soul::ast::re::MakeNfa(*lexerContext, *crv); 
            }
        |   CARET
            { 
                std::expected<soul::ast::re::Symbol*, int> rv = lexerContext->MakeChar('^');
                if (!rv) return std::unexpected<int>(rv.error());
                value = soul::ast::re::MakeNfa(*lexerContext, *rv); 
            }
        |   MINUS
            { 
                std::expected<soul::ast::re::Symbol*, int> rv = lexerContext->MakeChar('-');
                if (!rv) return std::unexpected<int>(rv.error());
                value = soul::ast::re::MakeNfa(*lexerContext, *rv); 
            }
        |   CHARACTER
            { 
                auto t = lexer.TokenToString(pos);
                if (!t) return std::unexpected<int>(t.error());
                auto c = *t;
                std::expected<soul::ast::re::Symbol*, int> rv = lexerContext->MakeChar(c.front());
                if (!rv) return std::unexpected<int>(rv.error());
                value = soul::ast::re::MakeNfa(*lexerContext, *rv); 
            }
        |   DOT{ value = soul::ast::re::MakeNfa(*lexerContext, lexerContext->MakeAny()); }
        |   Class(lexerContext):cls{ value = soul::ast::re::MakeNfa(*lexerContext, cls); }
        |   ExpressionReference:ref
            { 
                std::expected<soul::ast::re::Nfa, int> rv = lexerContext->MakeExpr(ref); 
                if (!rv) return std::unexpected<int>(rv.error());
                value = std::move(*rv);
            }
        )
        {
            return value;
        }
        ;

    Class(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Class* cls) : soul::ast::re::Class*
        ::= 
        (
            LBRACKET{ cls = lexerContext->MakeClass(); } 
            (
                (
                    CARET{ cls->SetInverse(); }
                )? 
                (
                    Range(lexerContext):r{ cls->AddSymbol(r); }
                )*
            ) 
            RBRACKET
        )
        {
            return cls;
        }
        ;

    Range(soul::ast::re::LexerContext* lexerContext, var soul::ast::re::Symbol* symbol) : soul::ast::re::Symbol*
        ::= 
        (
            Char:s 
            (   MINUS Char:e
                { 
                    std::expected<soul::ast::re::Symbol*, int> rv = lexerContext->MakeRange(s, e);
                    if (!rv) return std::unexpected<int>(rv.error());
                    symbol = *rv; 
                }
            |   empty
                { 
                    std::expected<soul::ast::re::Symbol*, int> rv = lexerContext->MakeChar(s);
                    if (!rv) return std::unexpected<int>(rv.error());
                    symbol = *rv; 
                }
            )
        )
        {
            return symbol;
        }
        ;

    Char : char32_t
        ::= LPAREN{ return '('; }
        |   RPAREN{ return ')'; }
        |   LBRACKET{ return '['; }
        |   LBRACE{ return '{'; }
        |   RBRACE{ return '}'; }
        |   PIPE{ return '|'; }
        |   STAR{ return '*'; }
        |   PLUS{ return '+'; }
        |   QUEST{ return '?'; }
        |   DOT{ return '.'; }
        |   ESCAPE
            { 
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                auto rv = soul::re::token::parser::MakeEscapeValue(lexer.FileName(), *t);
                if (!rv) return std::unexpected<int>(rv.error());
                return *rv;
            }
        |   CARET{ return '^'; }
        |   MINUS{ return '-'; }
        |   CHARACTER
            { 
                auto t = lexer.TokenToString(pos);
                if (!t) return std::unexpected<int>(t.error());
                auto c = *t;
                return c.front(); 
            }
        ;

    ExpressionReference(var std::string s) : std::string
        ::= 
        (
            LBRACE
            (
                CHARACTER
                { 
                    auto u = lexer.TokenToUtf8(pos);
                    if (!u) return std::unexpected<int>(u.error());
                    s.append(*u);
                }
            )+
            RBRACE{ return s; }
        )
        ;
}
