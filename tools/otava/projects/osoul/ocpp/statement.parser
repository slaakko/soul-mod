// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.cpp.statement.parser;

[interface]import soul.ast.cpp;
[implementation]import soul.cpp.token;
[implementation]import soul.cpp.op.token;
[implementation]import soul.tool.token;
[implementation]import soul.punctuation.token;
[implementation]import soul.cpp.declaration.parser;
[implementation]import soul.cpp.declarator.parser;
[implementation]import soul.cpp.expression.parser;
[implementation]import soul.lex;

parser StatementParser
{
    lexer soul::lex::slg::SlgLexer<char32_t>;
    lexer soul::lex::spg::SpgLexer<char32_t>;

    using DeclarationParser.SimpleDeclaration;
    using DeclarationParser.BlockDeclaration;
    using DeclarationParser.DeclSpecifierSeq;
    using DeclaratorParser.TypeId;
    using DeclaratorParser.TypeSpecifierSeq;
    using DeclaratorParser.Declarator;
    using DeclaratorParser.AbstractDeclarator;
    using ExpressionParser.Expression;
    using ExpressionParser.ConstantExpression;
    using ExpressionParser.AssignmentExpression;

    Statement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= LabeledStatement(context):labeledStatement{ return labeledStatement; }
        |   EmptyStatement(context):emptyStatement{ return emptyStatement; }
        |   CompoundStatement(context):compoundStatement{ return compoundStatement; }
        |   SelectionStatement(context):selectionStatement{ return selectionStatement; }
        |   IterationStatement(context):iterationStatement{ return iterationStatement; }
        |   JumpStatement(context):jumpStatement{ return jumpStatement; }
        |   DeclarationStatement(context):declarationStatement{ return declarationStatement; }
        |   ExpressionStatement(context):expressionStatement{ return expressionStatement; }  
        ;

    LabeledStatement(soul::ast::cpp::Context* context, var std::string label) : soul::ast::cpp::StatementNode*
        ::= ID
            { 
                auto u = lexer.TokenToUtf8(pos);
                if (!u) return std::unexpected<int>(u.error());
                label = *u; 
            } 
            COLON 
            Statement(context):stmt1
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::LabeledStatementNode(*sp, label, stmt1); 
            }
        |   CASE 
            ConstantExpression(context):caseExpr 
            COLON 
            Statement(context):stmt2
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::CaseStatementNode(*sp, caseExpr, stmt2); 
            }
        |   DEFAULT 
            COLON 
            Statement(context):stmt3
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::DefaultStatementNode(*sp, stmt3); 
            }
        ;

    EmptyStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= SEMICOLON
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::EmptyStatementNode(*sp); 
            }
        ;

    CompoundStatement(soul::ast::cpp::Context* context, var std::unique_ptr<soul::ast::cpp::CompoundStatementNode> compoundStatement) : 
        soul::ast::cpp::CompoundStatementNode*
        ::= 
        (
            LBRACE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                compoundStatement.reset(new soul::ast::cpp::CompoundStatementNode(*sp)); 
            }
            (
                Statement(context):stmt{ compoundStatement->Add(stmt); }
            )*
            RBRACE
        )
        {
            return compoundStatement.release();
        }
        ;

    SelectionStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= IfStatement(context):ifStatement{ return ifStatement; }
        |   SwitchStatement(context):switchStatement{ return switchStatement; }
        ;

    IfStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            IF LPAREN Condition(context):cond RPAREN Statement(context):thenS (ELSE Statement(context):elseS)?
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::IfStatementNode(*sp, cond, thenS, elseS);
        }
        ;

    SwitchStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            SWITCH LPAREN Condition(context):cond RPAREN Statement(context):stmt
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::SwitchStatementNode(*sp, cond, stmt);
        }
        ;

    IterationStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= WhileStatement(context):whileStatement{ return whileStatement; }
        |   DoStatement(context):doStatement{ return doStatement; }
        |   RangeForStatement(context):rangeForStatement{ return rangeForStatement; }
        |   ForStatement(context):forStatement{ return forStatement; }
        ;

    WhileStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            WHILE LPAREN Condition(context):cond RPAREN Statement(context):stmt
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::WhileStatementNode(*sp, cond, stmt);
        }
        ;

    DoStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::=
        (
            DO Statement(context):stmt WHILE LPAREN Expression(context):cond RPAREN SEMICOLON
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::DoStatementNode(*sp, cond, stmt);
        }
        ;

    RangeForStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            FOR LPAREN ForRangeDeclaration(context):forRangeDeclaration COLON Expression(context):container RPAREN Statement(context):stmt
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::RangeForStatementNode(*sp, forRangeDeclaration, container, stmt);
        }
        ;

    ForRangeDeclaration(soul::ast::cpp::Context* context, var std::unique_ptr<soul::ast::cpp::ForRangeDeclarationNode> forRangeDeclaration) : soul::ast::cpp::ForRangeDeclarationNode*
        ::= 
        (
            empty
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                forRangeDeclaration.reset(new soul::ast::cpp::ForRangeDeclarationNode(*sp)); 
            }
            DeclSpecifierSeq(context, forRangeDeclaration->Declaration()):declSpecifierSeq Declarator(context):declarator{ forRangeDeclaration->SetDeclarator(declarator); }
        )
        {
            return forRangeDeclaration.release();
        }
        ;

    ForStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= FOR LPAREN ForInitStatement(context):forInitStatement Condition(context):cond? SEMICOLON Expression(context):loopExpr? RPAREN Statement(context):stmt
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::ForStatementNode(*sp, forInitStatement, cond, loopExpr, stmt);
        }
        ;

    ForInitStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::Node*
        ::= EmptyStatement(context):emptyStatement{ return emptyStatement; }
        |   ExpressionStatement(context):expressionStatement{ return expressionStatement; }
        |   SimpleDeclaration(context):simpleDeclaration{ return simpleDeclaration; }
        ;

    JumpStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= BreakStatement(context):breakStatement{ return breakStatement; }
        |   ContinueStatement(context):continueStatement{ return continueStatement; }
        |   ReturnStatement(context):returnStatement{ return returnStatement; }
        |   GotoStatement(context):gotoStatement{ return gotoStatement; }
        ;
    
    BreakStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            BREAK SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::BreakStatementNode(*sp); 
        }
        ;

    ContinueStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            CONTINUE SEMICOLON
        )
        {
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::ContinueStatementNode(*sp); 
        }
        ;

    ReturnStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            RETURN Expression(context):returnValue? SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::ReturnStatementNode(*sp, returnValue); 
        }
        ;

    GotoStatement(soul::ast::cpp::Context* context, var std::string target) : soul::ast::cpp::StatementNode*
        ::= 
        (
            GOTO 
            ID
            { 
                auto u = lexer.TokenToUtf8(pos);
                if (!u) return std::unexpected<int>(u.error());
                target = *u; 
            } 
            SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::GotoStatementNode(*sp, target); 
        }
        ;

    DeclarationStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            BlockDeclaration(context):declaration
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::DeclarationStatementNode(*sp, declaration); 
        }
        ;

    Condition(soul::ast::cpp::Context* context) : soul::ast::cpp::Node*
        ::= 
        (   TypeId(context):typeId Declarator(context):declarator ASSIGN AssignmentExpression(context):assignmentExpr
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::ConditionWithDeclaratorNode(*sp, typeId, declarator, assignmentExpr); 
            }
        |   Expression(context):expr{ return expr; }
        )
        ;

    ExpressionStatement(soul::ast::cpp::Context* context) : soul::ast::cpp::StatementNode*
        ::= 
        (
            Expression(context):expr SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::ExpressionStatementNode(*sp, expr); 
        }
        ;
}
