// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.cpp.declaration.parser;

[interface]import soul.ast.cpp;
[implementation]import soul.cpp.token;
[implementation]import soul.cpp.op.token;
[implementation]import soul.punctuation.token;
[implementation]import soul.tool.token;
[implementation]import soul.cpp.expression.parser;
[implementation]import soul.cpp.identifier.parser;
[implementation]import soul.cpp.declarator.parser;
[implementation]import soul.lex;

parser DeclarationParser
{
    lexer soul::lex::slg::SlgLexer<char32_t>;
    lexer soul::lex::spg::SpgLexer<char32_t>;

    using CppIdentifierParser.CppIdentifier;
    using CppIdentifierParser.QualifiedCppId;
    using DeclaratorParser.InitDeclaratorList;
    using DeclaratorParser.TypeId;
    using ExpressionParser.AssignmentExpression;

    BlockDeclaration(soul::ast::cpp::Context* context) : soul::ast::cpp::Node*
        ::= NamespaceAliasDefinition(context):nsAlias{ return nsAlias; }
        |   UsingDirective(context):usingDirective{ return usingDirective; }
        |   UsingDeclaration(context):usingDeclaration{ return usingDeclaration; }
        |   SimpleDeclaration(context):simpleDeclaration{ return simpleDeclaration; }
        ;

    SimpleDeclaration(soul::ast::cpp::Context* context, 
        var std::unique_ptr<soul::ast::cpp::SimpleDeclarationNode> simpleDeclaration) : soul::ast::cpp::SimpleDeclarationNode*
        ::= empty
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                simpleDeclaration.reset(new soul::ast::cpp::SimpleDeclarationNode(*sp)); 
            }
            (DeclSpecifierSeq(context, simpleDeclaration.get()):declSpecifierSeq)?
            (InitDeclaratorList(context):initDeclaratorList{ simpleDeclaration->SetInitDeclaratorList(initDeclaratorList); })?
            SEMICOLON
        {
            return simpleDeclaration.release();
        }
        ;

    DeclSpecifierSeq(soul::ast::cpp::Context* context, soul::ast::cpp::SimpleDeclarationNode* declaration)
        ::= 
        (
            (
                DeclSpecifier(context):declSpecifier{ declaration->Add(declSpecifier); }
            )+
            |   TypeName(context):typeName{ declaration->Add(typeName); }
        )
        ;

    DeclSpecifier(soul::ast::cpp::Context* context) : soul::ast::cpp::DeclSpecifierNode*
        ::= StorageClassSpecifier(context):storateClassSpecifier{ return storateClassSpecifier; }
        |   TypeSpecifier(context):typeSpecifier{ return typeSpecifier; }
        |   Typedef(context):tdef{ return tdef; }
        ;

    StorageClassSpecifier(soul::ast::cpp::Context* context) : soul::ast::cpp::StorageClassSpecifierNode*
        ::= AUTO
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::StorageClassSpecifierNode(*sp, "auto"); 
            }
        |   REGISTER
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::StorageClassSpecifierNode(*sp, "register"); 
            }
        |   STATIC
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::StorageClassSpecifierNode(*sp, "static"); 
            }
        |   EXTERN
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::StorageClassSpecifierNode(*sp, "extern"); 
            }
        |   MUTABLE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::StorageClassSpecifierNode(*sp, "mutable"); 
            }
        ;

    TypeSpecifier(soul::ast::cpp::Context* context) : soul::ast::cpp::TypeSpecifierNode*
        ::= SimpleTypeSpecifier(context):simpleTypeSpecifier{ return simpleTypeSpecifier; }
        |   CVQualifier(context):cvQualifier{ return cvQualifier; }
        ;

    SimpleTypeSpecifier(soul::ast::cpp::Context* context) : soul::ast::cpp::TypeSpecifierNode*
        ::= CHAR
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "char"); 
            }
        |   CHAR8T
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "char8_t"); 
            }
        |   CHAR16T
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "char16_t"); 
            }
        |   CHAR32T
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "char32_t"); 
            }
        |   WCHART
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "wchar_t"); 
            }
        |   BOOL
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "bool"); 
            }
        |   SHORT
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "short"); 
            }
        |   INT
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "int"); 
            }
        |   LONG
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "long"); 
            }
        |   SIGNED
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "signed"); 
            }
        |   UNSIGNED
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "unsigned"); 
            }
        |   FLOAT
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "float"); 
            }
        |   DOUBLE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "double"); 
            }
        |   VOID
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypeSpecifierNode(*sp, "void"); 
            }
        ;

    TypeName(soul::ast::cpp::Context* context, var std::unique_ptr<soul::ast::cpp::TypeNameNode> typeName) : soul::ast::cpp::TypeNameNode*
        ::=
        (
            QualifiedCppId(context):qid
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                typeName.reset(new soul::ast::cpp::TypeNameNode(*sp, qid)); 
            }
            (
                LANGLE{ ++vars->leftAngleCount; typeName->SetTemplate(); context->BeginParsingTemplateId(); } 
                TemplateArgumentList(context, typeName.get()):args 
                RANGLE{ --vars->leftAngleCount; context->EndParsingTemplateId(); }
            )?
        )
        {
            return typeName.release();
        }
        ;

    TemplateArgumentList(soul::ast::cpp::Context* context, soul::ast::cpp::TypeNameNode* typeName)
        ::= TemplateArgument(context):arg{ typeName->AddTemplateArgument(arg); } % COMMA
        ;

    TemplateArgument(soul::ast::cpp::Context* context) : soul::ast::cpp::Node*
        ::= TypeId(context):typeId{ return typeId; }
        |   AssignmentExpression(context):assignmentExpr{ return assignmentExpr; }
        ;

    Typedef(soul::ast::cpp::Context* context) : soul::ast::cpp::DeclSpecifierNode*
        ::= TYPEDEF
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::TypedefNode(*sp); 
            }
        ;

    CVQualifier(soul::ast::cpp::Context* context) : soul::ast::cpp::TypeSpecifierNode*
        ::= CONST
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::ConstNode(*sp); 
            }
        |   VOLATILE
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::VolatileNode(*sp); 
            }
        ;

    NamespaceAliasDefinition(soul::ast::cpp::Context* context) : soul::ast::cpp::UsingObjectNode*
        ::= (
                NAMESPACE CppIdentifier(context):id ASSIGN QualifiedCppId(context):qid SEMICOLON
            )
            { 
                auto sp = lexer.GetSourcePos(pos);
                if (!sp) return std::unexpected<int>(sp.error());
                return new soul::ast::cpp::NamespaceAliasNode(*sp, id, qid); 
            }
        ;

    UsingDeclaration(soul::ast::cpp::Context* context) : soul::ast::cpp::UsingObjectNode*
        ::= 
        (
            USING 
            QualifiedCppId(context):qid 
            SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::UsingDeclarationNode(*sp, qid); 
        }
        ;

    UsingDirective(soul::ast::cpp::Context* context) : soul::ast::cpp::UsingObjectNode*
        ::= 
        (
            USING 
            NAMESPACE 
            QualifiedCppId(context):ns 
            SEMICOLON
        )
        { 
            auto sp = lexer.GetSourcePos(pos);
            if (!sp) return std::unexpected<int>(sp.error());
            return new soul::ast::cpp::UsingDirectiveNode(*sp, ns); 
        }
        ;
}
