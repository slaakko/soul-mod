// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.slg.lexer.file.parser;

[interface]import soul.ast.slg;
[interface]import soul.ast.cpp;
[implementation]import soul.cpp.token;
[implementation]import soul.cpp.op.token;
[implementation]import soul.punctuation.token;
[implementation]import soul.tool.token;
[implementation]import soul.common.common.parser;
[implementation]import soul.common.token.parser;
[implementation]import soul.cpp.statement.parser;
[implementation]import soul.cpp.declarator.parser;
[implementation]import soul.ast.cpp;
[implementation]import soul.ast.common;
[implementation]import soul.lex;

parser LexerFileParser
{
    lexer soul::lex::slg::SlgLexer<char32_t>;

    main;
    using CommonParser.QualifiedId;
    using CommonParser.Export;
    using CommonParser.Import;
    using CommonParser.ExprString;
    using CommonParser.LexerKeyword;
    using StatementParser.CompoundStatement;
    using DeclaratorParser.TypeId;

    LexerFile(soul::ast::cpp::Context* context, var std::unique_ptr<soul::ast::slg::LexerFile> lexerFile, 
        var std::unique_ptr<soul::ast::slg::Lexer> lxr) : soul::ast::slg::LexerFile*
        ::= 
        (
            empty{ lexerFile.reset(new soul::ast::slg::LexerFile(lexer.FileName())); }
            Export:exportModule{ lexerFile->SetExportModule(exportModule); }
            Imports(lexerFile.get()):imports
            LexerKeyword:lexerKeyword
            ID
            { 
                auto rv = lexer.TokenToUtf8(pos);
                if (!rv) return std::unexpected<int>(rv.error());
                lxr.reset(new soul::ast::slg::Lexer(*rv)); 
            }
            LBRACE
            (
                LexerContent(context, lxr.get()):content
            )*
            RBRACE
        )
        {
            lexerFile->SetLexer(lxr.release());
            return lexerFile.release();
        }
        ;

    Imports(soul::ast::slg::LexerFile* lexerFile)
        ::= (Import:imp{ lexerFile->AddImport(imp); })*
        ;

    LexerContent(soul::ast::cpp::Context* context, soul::ast::slg::Lexer* lxr)
        ::= 
        (   Rules(context, lxr):rls
        |   Variables(context, lxr):vars
        |   Actions(context, lxr):actns
        )
        ;

    Rules(soul::ast::cpp::Context* context, soul::ast::slg::Lexer* lxr)
        ::= 
        (
            RULES
            LBRACE
            (
                Rule(context):rl{ lxr->AddRule(rl); }
            )*
            RBRACE
        )
        ;

    Rule(soul::ast::cpp::Context* context, var int line) : soul::ast::slg::Rule*
        ::= 
        (
            ExprString:expr
            { 
                auto t = lexer.GetToken(pos);
                if (!t) return std::unexpected<int>(t.error());
                const auto* token = *t;
                line = token->line; 
            }
            Action(context):action
            CompoundStatement(context):code
        )
        {
            return new soul::ast::slg::Rule(expr, code, action, line);
        }
        ;

    Variables(soul::ast::cpp::Context* context, soul::ast::slg::Lexer* lxr)
        ::= 
        (
            VARIABLES
            LBRACE
            (
                Variable(context):variable{ lxr->AddVariable(variable); }
            )*
            RBRACE
        )
        ;

    Variable(soul::ast::cpp::Context* context, var std::string name) : soul::ast::slg::Variable*
        ::= 
        (
            TypeId(context):type 
            ID
            { 
                auto rv = lexer.TokenToUtf8(pos);
                if (!rv) return std::unexpected<int>(rv.error());
                name = *rv;
            }
            SEMICOLON
        )
        {
            return new soul::ast::slg::Variable(type, name);
        }
        ;
		
    Actions(soul::ast::cpp::Context* context, soul::ast::slg::Lexer* lxr, var int actionId)
        ::= 
        (
            ACTIONS
            LBRACE
            (
                Action(context):action{ actionId = action; pass = actionId != -1; } 
                ASSIGN CompoundStatement(context):stmt{ lxr->AddAction(new soul::ast::slg::Action(actionId, stmt)); }
            )*
            RBRACE
        )
        ;

    Action(soul::ast::cpp::Context* context, var int actionId) : int
        ::= DOLLAR 
            LPAREN 
            INTEGER_LITERAL
            { 
                auto rv = lexer.TokenToInt(pos);
                if (!rv) return std::unexpected<int>(rv.error());
                actionId = *rv;
            } 
            RPAREN
            { 
                return actionId; 
            }
        |   empty{ return -1; }
        ;
}
