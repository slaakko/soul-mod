// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.cpp20.parser.classes;

[interface]import soul.cpp20.symbols.context;
[interface]import soul.cpp20.ast;
[implementation]import soul.cpp20.token;
[implementation]import soul.cpp20.lexer;
[implementation]import soul.cpp20.symbols;
[implementation]import soul.cpp20.parser.attribute;
[implementation]import soul.cpp20.parser.concepts;
[implementation]import soul.cpp20.parser.declaration;
[implementation]import soul.cpp20.parser.enums;
[implementation]import soul.cpp20.parser.expression;
[implementation]import soul.cpp20.parser.function;
[implementation]import soul.cpp20.parser.identifier;
[implementation]import soul.cpp20.parser.initialization;
[implementation]import soul.cpp20.parser.punctuation;
[implementation]import soul.cpp20.parser.templates;
[implementation]import soul.cpp20.parser.type;

parser ClassParser
{
    lexer soul::cpp20::lexer::Cpp20Lexer<char32_t>;

    using AttributeParser.AttributeSpecifierSeq;
    using ConceptParser.RequiresClause;
    using DeclarationParser.AliasDeclaration;
    using DeclarationParser.Declarator;
    using DeclarationParser.DeclSpecifierSeq;
    using DeclarationParser.EmptyDeclaration;
    using DeclarationParser.UsingDeclaration;
    using DeclarationParser.UsingEnumDeclaration;
    using DeclarationParser.StaticAssertDeclaration;
    using EnumParser.OpaqueEnumDeclaration;
    using ExpressionParser.ExpressionList;
    using FunctionParser.FunctionDefinition;
    using IdentifierParser.Identifier;
    using IdentifierParser.NestedNameSpecifier;
    using IdentifierParser.Unnamed;
    using InitializationParser.BracedInitList;
    using InitializationParser.BraceOrEqualInitializer;
    using PunctuationParser.Comma;
    using PunctuationParser.Ellipsis;
    using PunctuationParser.Semicolon;
    using TemplateParser.DeductionGuide;
    using TemplateParser.ExplicitSpecialization;
    using TemplateParser.SimpleTemplateId;
    using TemplateParser.Template;
    using TemplateParser.TemplateDeclaration;
    using TypeParser.DeclTypeSpecifier;
    using TypeParser.TypeName;

    ClassSpecifier(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::ClassSpecifierNode> node, 
        var soul::ast::SourcePos lbPos, var soul::ast::SourcePos rbPos) : soul::cpp20::ast::Node*
        ::= 
        (
            ClassHead(context):classHead{ sourcePos = lexer.GetSourcePos(pos); } 
            LBRACE
            { 
                lbPos = lexer.GetSourcePos(pos); 
                node.reset(new soul::cpp20::ast::ClassSpecifierNode(sourcePos, classHead)); 
                soul::cpp20::symbols::BeginClass(node.get(), context); 
            } 
            MemberSpecification(context, node.get()):memberSpec? 
            RBRACE{ rbPos = lexer.GetSourcePos(pos); }
        )
        {
            node->SetLBracePos(lbPos);
            node->SetRBracePos(rbPos);
            soul::cpp20::symbols::EndClass(context);
            return node.release();
        }
        ;

    ClassHead(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= 
        (
            ClassKey:classKey{ sourcePos = lexer.GetSourcePos(pos); } AttributeSpecifierSeq(context):attributes? 
            (   (ClassHeadName(context):classHeadName ClassVirtSpecifier(context):classVirtSpecifier? BaseClause(context):baseClause?)
                {
                    return new soul::cpp20::ast::ClassHeadNode(sourcePos, classKey, classHeadName, classVirtSpecifier, baseClause, attributes);
                }
            |   (Unnamed:unnamed BaseClause(context):baseClause2?)
                {
                    return new soul::cpp20::ast::ClassHeadNode(sourcePos, classKey, unnamed, nullptr, baseClause2, attributes);
                }
            )
        )
        ;

    ClassKey : soul::cpp20::ast::Node*
        ::= CLASS{ return new soul::cpp20::ast::ClassNode(lexer.GetSourcePos(pos)); }
        |   STRUCT{ return new soul::cpp20::ast::StructNode(lexer.GetSourcePos(pos)); }
        |   UNION{ return new soul::cpp20::ast::UnionNode(lexer.GetSourcePos(pos)); }
        ;

    ClassHeadName(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= NestedNameSpecifier(context):nns{ sourcePos = lexer.GetSourcePos(pos); } 
            ClassName(context):className{ return new soul::cpp20::ast::QualifiedIdNode(sourcePos, nns, className); }
        |   ClassName(context):className2{ return className2; }
        ;

    ClassName(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= SimpleTemplateId(context):templateId{ return templateId; }
        |   Identifier(context):identifier{ return identifier; }
        ;

    ClassVirtSpecifier(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= FinalKeyword(context):finalKw{ return finalKw; }
        ;

    VirtSpecifierSeq(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::Node> node) : soul::cpp20::ast::Node*
        ::= 
        (
            VirtSpecifier(context):first{ node.reset(new soul::cpp20::ast::VirtSpecifierSequenceNode(lexer.GetSourcePos(pos))); node->AddNode(first); } 
            (
                VirtSpecifier(context):next{ node->AddNode(next); }
            )*
        )
        {
            return node.release();
        }
        ;

    VirtSpecifier(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= OverrideKeyword(context):overrideKw{ return overrideKw; }
        |   FinalKeyword(context):finalKw{ return finalKw; }
        ;

    OverrideKeyword(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= 
        (
            ID{ sourcePos = lexer.GetSourcePos(pos); std::u32string id = lexer.GetToken(pos).ToString(); pass = id == U"override"; }
        )
        {
            return new soul::cpp20::ast::OverrideNode(sourcePos);
        }
        ;

    FinalKeyword(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= 
        (
            ID{ sourcePos = lexer.GetSourcePos(pos); std::u32string id = lexer.GetToken(pos).ToString(); pass = id == U"final"; }
        )
        {
            return new soul::cpp20::ast::FinalNode(sourcePos);
        }
        ;

    BaseClause(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= COLON{ sourcePos = lexer.GetSourcePos(pos); } 
            BaseSpecifierList(context):baseSpecifierList
        {
            return new soul::cpp20::ast::BaseClauseNode(sourcePos, baseSpecifierList);
        }
        ;

    BaseSpecifierList(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::Node> node) : soul::cpp20::ast::Node*
        ::= 
        (
            BaseSpecifier(context):first{ node.reset(new soul::cpp20::ast::BaseSpecifierListNode(lexer.GetSourcePos(pos))); node->AddNode(first); } 
            (
                Comma:comma{ node->AddNode(comma); } 
                BaseSpecifier(context):next{ node->AddNode(next); }
            )*
            (Ellipsis:ellipsis{ node->AddNode(ellipsis); })?
        )
        {
            return node.release();
        }
        ;

    BaseSpecifier(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::Node> accessSpecifierNode, 
        var std::unique_ptr<soul::cpp20::ast::Node> virtualSpecifier, var bool virtualFirst) : soul::cpp20::ast::Node*
        ::= 
        (
            (AttributeSpecifierSeq(context):attributes{ sourcePos = lexer.GetSourcePos(pos); })?
            (   VirtualSpecifier:virt{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); virtualSpecifier.reset(virt); virtualFirst = true; } 
                (AccessSpecifier:access{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); accessSpecifierNode.reset(access); })? 
            |   AccessSpecifier:access2{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); accessSpecifierNode.reset(access2); } 
                (VirtualSpecifier:virt2{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); virtualSpecifier.reset(virt2); })?
            |   empty
            )
            ClassOrDeclType(context):classOrDeclType{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); }
        )
        {
            return new soul::cpp20::ast::BaseSpecifierNode(sourcePos, classOrDeclType, accessSpecifierNode.release(), virtualSpecifier.release(), attributes, virtualFirst);
        }
        ;

    ClassOrDeclType(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos tmpPos) : soul::cpp20::ast::Node*
        ::= NestedNameSpecifier(context):nns{ sourcePos = lexer.GetSourcePos(pos); } 
            Template:tmp{ tmpPos = sourcePos; } 
            SimpleTemplateId(context):simpleTemplateId
            { 
                return new soul::cpp20::ast::QualifiedIdNode(sourcePos, nns, new soul::cpp20::ast::PrefixNode(tmpPos, tmp, simpleTemplateId)); 
            }
        |   NestedNameSpecifier(context):nns2{ sourcePos = lexer.GetSourcePos(pos); } 
            Identifier(context):id
            { 
                return new soul::cpp20::ast::QualifiedIdNode(sourcePos, nns2, id); 
            }
        |   TypeName(context):typeName2{ return typeName2; }
        |   DeclTypeSpecifier(context):declTypeSpecifier{ return declTypeSpecifier; }
        ;

    MemberSpecification(soul::cpp20::symbols::Context* context, soul::cpp20::ast::Node* container, var soul::ast::SourcePos sourcePos, var soul::ast:: SourcePos colonPos)
        ::= 
        (   AccessSpecifier:accessSpecifier{ sourcePos = lexer.GetSourcePos(pos); } 
            COLON{ colonPos = lexer.GetSourcePos(pos); container->AddNode(new soul::cpp20::ast::BeginAccessGroupNode(sourcePos, accessSpecifier, colonPos)); }
        |   MemberDeclaration(context):memberDeclaration1{ container->AddNode(memberDeclaration1); }
        |   MemberDeclaration(context):memberDeclaration2{ container->AddNode(memberDeclaration2); }
        )+
        ;

    MemberDeclaration(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::Node> declSpecifiersNode, 
        var std::unique_ptr<soul::cpp20::ast::Node> declaratorsNode) : soul::cpp20::ast::Node*
        ::= (AttributeSpecifierSeq(context):attributes{ sourcePos = lexer.GetSourcePos(pos); })? 
            (MemberDeclSpecifiers(context):declSpecifiers{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); declSpecifiersNode.reset(declSpecifiers); })? 
            (MemberDeclaratorList(context):declarators{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); declaratorsNode.reset(declarators); })? 
            (Semicolon:semicolon{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); })
            {
                if (!declSpecifiersNode && !declaratorsNode) pass = false;
                else
                {
                    soul::cpp20::ast::MemberDeclarationNode* memberDeclarationNode = new soul::cpp20::ast::MemberDeclarationNode(sourcePos, attributes, declSpecifiersNode.release(), 
                        declaratorsNode.release(), semicolon);
                    soul::cpp20::symbols::ProcessMemberDeclaration(memberDeclarationNode, context);
                    return memberDeclarationNode;
                }
            }
        |   (AttributeSpecifierSeq(context):attributes2{ sourcePos = lexer.GetSourcePos(pos); })? 
            RetMemberDeclSpecifiers(context):declSpecifiers2{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); declSpecifiersNode.reset(declSpecifiers2); }
            MemberDeclaratorList(context):declarators2{ declaratorsNode.reset(declarators2); }
            Semicolon:semicolon2
            {
                soul::cpp20::ast::MemberDeclarationNode* memberDeclarationNode = new soul::cpp20::ast::MemberDeclarationNode(sourcePos, attributes2, declSpecifiersNode.release(), 
                    declaratorsNode.release(), semicolon2);
                soul::cpp20::symbols::ProcessMemberDeclaration(memberDeclarationNode, context);
                return memberDeclarationNode;
            }
        |   MemberFunctionDefinition(context):memberFunctionDefinition
            { 
                std::unique_ptr<soul::cpp20::ast::Node> memFunDefNode;
                memFunDefNode.reset(memberFunctionDefinition);
                soul::cpp20::symbols::ProcessMemberFunctionDefinition(memFunDefNode.get(), context);
                return memFunDefNode.release(); 
            }
        |   RetMemberFunctionDefinition(context):retMemberFunctionDefinition
            { 
                std::unique_ptr<soul::cpp20::ast::Node> memFunDefNode;
                memFunDefNode.reset(retMemberFunctionDefinition);
                soul::cpp20::symbols::ProcessMemberFunctionDefinition(memFunDefNode.get(), context);
                return memFunDefNode.release(); 
            }
        |   UsingDeclaration(context):usingDeclaration{ return usingDeclaration; }
        |   UsingEnumDeclaration(context):usingEnumDeclaration{ return usingEnumDeclaration; }
        |   StaticAssertDeclaration(context):staticAssertDeclaration{ return staticAssertDeclaration; }
        |   MemberTemplateDeclaration(context):templateDeclaration{ return templateDeclaration; }
        |   ExplicitSpecialization(context):explicitSpecialization{ return explicitSpecialization; }
        |   DeductionGuide(context):deductionGuide{ return deductionGuide; }
        |   AliasDeclaration(context):aliasDeclaration{ return aliasDeclaration; }
        |   OpaqueEnumDeclaration(context):opaqueEnumDeclaration{ return opaqueEnumDeclaration; }
        |   EmptyDeclaration:emptyDeclaration{ return emptyDeclaration; }
        ;

    MemberDeclSpecifiers(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= DeclSpecifierSeq(context):declSpecifiers{ return declSpecifiers; }
        ;

    RetMemberDeclSpecifiers(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= empty{ context->PushSetFlag(ContextFlags::retMemberDeclSpecifiers); }
            DeclSpecifierSeq(context):declSpecifiers{ context->PopFlags(); return declSpecifiers; } / { context->PopFlags(); }
        ;

    MemberFunctionDefinition(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= FunctionDefinition(context):functionDefinition{ return functionDefinition; }
        ;

    RetMemberFunctionDefinition(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= empty{ context->PushSetFlag(ContextFlags::retMemberDeclSpecifiers); }
            FunctionDefinition(context):functionDefinition{ context->PopFlags(); return functionDefinition; } / { context->PopFlags(); }
        ;

    MemberTemplateDeclaration(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= TemplateDeclaration(context):templateDeclaration{ return templateDeclaration; }
        ;

    MemberDeclaratorList(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::Node> node) : soul::cpp20::ast::Node*
        ::= 
        (
            MemberDeclarator(context):first{ node.reset(new soul::cpp20::ast::MemberDeclaratorListNode(lexer.GetSourcePos(pos))); node->AddNode(first); }
            (
                Comma:comma{ node->AddNode(comma); } 
                MemberDeclarator(context):next{ node->AddNode(next); }
            )*
        )
        {
            return node.release();
        }
        ;

    MemberDeclarator(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::TrailingQualifiersNode> trailingQualifiersNode) : 
        soul::cpp20::ast::Node*
        ::= 
        (
            Declarator(context):declarator{ sourcePos = lexer.GetSourcePos(pos); } 
            (   RequiresClause(context):requiresClause{ return new soul::cpp20::ast::InitDeclaratorNode(sourcePos, declarator, requiresClause); }
            |   BraceOrEqualInitializer(context):initializer{ return new soul::cpp20::ast::InitDeclaratorNode(sourcePos, declarator, initializer); }
            |   empty{ trailingQualifiersNode.reset(new soul::cpp20::ast::TrailingQualifiersNode(sourcePos, declarator)); }
            )
            (VirtSpecifierSeq(context):virtSpecifierSeq{ trailingQualifiersNode->AddNode(virtSpecifierSeq); })?
            (PureSpecifier:pureSpecifier{ trailingQualifiersNode->AddNode(pureSpecifier); })?
        )
        {
            if (trailingQualifiersNode->Nodes().IsEmpty())
            {
                return trailingQualifiersNode->ReleaseSubject();
            }
            else
            {
                return trailingQualifiersNode.release();
            }
        }
        ;    


    CtorInitializer(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= COLON{ sourcePos = lexer.GetSourcePos(pos); } 
            MemberInitializerList(context):memberInitializerList
        {
            return new soul::cpp20::ast::ConstructorInitializerNode(sourcePos, memberInitializerList);
        }
        ;

    MemberInitializerList(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::Node> node) : soul::cpp20::ast::Node*
        ::= 
        (   
            MemberInitializer(context):first{ node.reset(new soul::cpp20::ast::MemberInitializerListNode(lexer.GetSourcePos(pos))); node->AddNode(first); }
            (
                Comma:comma{ node->AddNode(comma); } 
                MemberInitializer(context):next{ node->AddNode(next); }
            )*
            (Ellipsis:ellipsis{ node->AddNode(ellipsis); })?
        )
        {
            return node.release();
        }
        ;

    MemberInitializer(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::ExpressionListNode> exprListNode, 
        var std::unique_ptr<soul::cpp20::ast::Node> node) : soul::cpp20::ast::Node*
        ::= 
        (   MemberInitializerId(context):id{ sourcePos = lexer.GetSourcePos(pos); }
            (
                LPAREN{ exprListNode.reset(new soul::cpp20::ast::ExpressionListNode(sourcePos)); exprListNode->SetLParenPos(sourcePos); } 
                ExpressionList(context, exprListNode.get()):expressionList?
                RPAREN{ exprListNode->SetRParenPos(sourcePos); node.reset(exprListNode.release()); }
            |   BracedInitList(context):bracedInitList{ node.reset(bracedInitList); }
            )
        )
        {
            return new soul::cpp20::ast::MemberInitializerNode(sourcePos, id, node.release());
        }
        ;

    MemberInitializerId(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= ClassOrDeclType(context):classOrDeclType{ return classOrDeclType; }
        |   Identifier(context):identifier{ return identifier; }
        ;

    PureSpecifier(var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos zeroPos) : soul::cpp20::ast::Node*
        ::= 
        (
            ASSIGN{ sourcePos = lexer.GetSourcePos(pos); } 
            INTEGER_LITERAL{ zeroPos = lexer.GetSourcePos(pos); std::u32string value = lexer.GetToken(pos).ToString(); pass = value == U"0"; }
        )
        {
            return new soul::cpp20::ast::PureSpecifierNode(sourcePos, zeroPos);
        }
        ;

    AccessSpecifier : soul::cpp20::ast::Node*
        ::= PUBLIC{ return new soul::cpp20::ast::PublicNode(lexer.GetSourcePos(pos)); }
        |   PROTECTED{ return new soul::cpp20::ast::ProtectedNode(lexer.GetSourcePos(pos)); }
        |   Private:privat{ return privat; }
        ;

    Private : soul::cpp20::ast::Node*
        ::= PRIVATE{ return new soul::cpp20::ast::PrivateNode(lexer.GetSourcePos(pos)); }
        ;

    VirtualSpecifier : soul::cpp20::ast::Node*
        ::= VIRTUAL{ return new soul::cpp20::ast::VirtualNode(lexer.GetSourcePos(pos)); }
        ;

}
