// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.cpp20.parser.templates;

[interface]import soul.cpp20.symbols.context;
[implementation]import soul.cpp20.ast;
[implementation]import soul.cpp20.token;
[implementation]import soul.cpp20.lexer;
[implementation]import soul.cpp20.symbols;
[implementation]import soul.cpp20.parser.concepts;
[implementation]import soul.cpp20.parser.declaration;
[implementation]import soul.cpp20.parser.function;
[implementation]import soul.cpp20.parser.expression;
[implementation]import soul.cpp20.parser.identifier;
[implementation]import soul.cpp20.parser.literal;
[implementation]import soul.cpp20.parser.punctuation;
[implementation]import soul.cpp20.parser.type;

parser TemplateParser
{
    lexer soul::cpp20::lexer::Cpp20Lexer<char32_t>;

    using ConceptParser.ConceptDefinition;
    using ConceptParser.RequiresClause;
    using ConceptParser.TypeConstraint;
    using DeclarationParser.Declaration;
    using ExpressionParser.ConstantExpression;
    using ExpressionParser.IdExpression;
    using FunctionParser.OperatorFunctionId;
    using FunctionParser.ParameterDeclaration;
    using IdentifierParser.Identifier;
    using LiteralParser.LiteralOperatorId;
    using PunctuationParser.Assign;
    using PunctuationParser.Comma;
    using PunctuationParser.Ellipsis;
    using TypeParser.TypeId;

    TemplateDeclaration(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::Node> templateHeadNode, 
        var soul::ast::SourcePos sourcePos) : soul::cpp20::ast::Node*
        ::= TemplateHead(context, true):templateHead{ templateHeadNode.reset(templateHead); sourcePos = lexer.GetSourcePos(pos); }
            (   ConceptDefinition(context):concepDefinition
                { 
                    soul::cpp20::symbols::EndTemplateDeclaration(context); 
                    return new soul::cpp20::ast::TemplateDeclarationNode(sourcePos, templateHeadNode.release(), concepDefinition); 
                }
            |   Declaration(context):declaration
                { 
                    soul::cpp20::symbols::EndTemplateDeclaration(context); 
                    return new soul::cpp20::ast::TemplateDeclarationNode(sourcePos, templateHeadNode.release(), declaration); 
                }
            |   empty{ soul::cpp20::symbols::RemoveTemplateDeclaration(context); pass = false; }
            )
        ;

    TemplateHead(soul::cpp20::symbols::Context* context, bool begin, var soul::ast::SourcePos sourcePos, var std::unique_ptr<soul::cpp20::ast::TemplateHeadNode> templateHeadNode) : 
        soul::cpp20::ast::Node*
        ::= 
        (
            TEMPLATE
            { 
                sourcePos = lexer.GetSourcePos(pos); 
                templateHeadNode.reset(new soul::cpp20::ast::TemplateHeadNode(sourcePos)); 
                if (begin) 
                {
                    soul::cpp20::symbols::BeginTemplateDeclaration(templateHeadNode.get(), context); 
                }
            }
            TemplateParameterList(context):templateParamList{ templateHeadNode->SetTemplateParameterList(templateParamList); }
            (RequiresClause(context):requiresClause{ templateHeadNode->SetRequiresClause(requiresClause); })?
        )
        {
            return templateHeadNode.release();
        }
        ;

    TemplateParameterList(soul::cpp20::symbols::Context* context, var int index, var std::unique_ptr<soul::cpp20::ast::Node> templateParameterNode, 
        var std::unique_ptr<soul::cpp20::ast::TemplateParameterListNode> node, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : soul::cpp20::ast::Node*
        ::= 
        (
            LANGLE{ soul::ast::SourcePos sourcePos = lexer.GetSourcePos(pos); node.reset(new soul::cpp20::ast::TemplateParameterListNode(sourcePos)); laPos = sourcePos; } 
            TemplateParameter(context):first
            { 
                templateParameterNode.reset(first); 
                soul::cpp20::symbols::AddTemplateParameter(templateParameterNode.get(), index, context); 
                node->AddNode(templateParameterNode.release()); 
                index = index + 1; 
            } 
            (
                Comma:comma{ node->AddNode(comma); } 
                TemplateParameter(context):next
                { 
                    templateParameterNode.reset(next); 
                    soul::cpp20::symbols::AddTemplateParameter(templateParameterNode.get(), index, context); 
                    node->AddNode(templateParameterNode.release()); 
                    index = index + 1; 
                }
            )*
            RANGLE{ raPos = lexer.GetSourcePos(pos); }
        )
        {
            node->SetLAnglePos(laPos);
            node->SetRAnglePos(raPos);
            return node.release();
        }
        ;

    TemplateParameter(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= TypeParameter(context):typeParam{ return typeParam; }
        |   ParameterDeclaration(context):param{ return param; }
        ;

    TypeParameter(soul::cpp20::symbols::Context* context, var soul::ast::SourcePos sourcePos, 
        var std::unique_ptr<soul::cpp20::ast::Node> ellipsisNode, var std::unique_ptr<soul::cpp20::ast::Node> identifierNode) : soul::cpp20::ast::Node*
        ::= (TemplateHead(context, false):templateHead{ sourcePos = lexer.GetSourcePos(pos); })?
            (   TypeParameterKey:key{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); }
                (   Identifier(context):id 
                    Assign:asgn 
                    (   IdExpression(context):idExpr{ return new soul::cpp20::ast::TypeParameterNode(sourcePos, key, id, asgn, idExpr, nullptr, templateHead); }
                    |   TypeId(context):typeId{ return new soul::cpp20::ast::TypeParameterNode(sourcePos, key, id, asgn, typeId, nullptr, templateHead); }
                    )
                |   (Ellipsis:ellipsis? Identifier(context):id2?)
                    {
                        ellipsisNode.reset(ellipsis);
                        identifierNode.reset(id2);
                        if (!ellipsisNode && !identifierNode)
                        {
                            pass = false;
                        }
                        else
                        {
                            return new soul::cpp20::ast::TypeParameterNode(sourcePos, key, identifierNode.release(), nullptr, nullptr, ellipsisNode.release(), templateHead); 
                        }
                    }
                )
            |   TypeConstraint(context):constraint{ if (!sourcePos.IsValid()) sourcePos = lexer.GetSourcePos(pos); }
                (   Identifier(context):id3 
                    Assign:asgn2 
                    TypeId(context):typeId2{ return new soul::cpp20::ast::TypeParameterNode(sourcePos, constraint, id3, asgn2, typeId2, nullptr, templateHead); }
                |   (Ellipsis:ellipsis2? Identifier(context):id4?)
                    {
                        ellipsisNode.reset(ellipsis2);
                        identifierNode.reset(id4);
                        if (!ellipsisNode && !identifierNode)
                        {
                            pass = false;
                        }
                        else
                        {
                            return new soul::cpp20::ast::TypeParameterNode(sourcePos, constraint, identifierNode.release(), nullptr, nullptr, ellipsisNode.release(), templateHead); 
                        }
                    }
                )
            )
        ;

    TypeParameterKey : soul::cpp20::ast::Node*
        ::= Typename:typename_{ return typename_; }
        |   Class:cls{ return cls; }
        ;

    Typename : soul::cpp20::ast::Node*
        ::= TYPENAME{ return new soul::cpp20::ast::TypenameNode(lexer.GetSourcePos(pos)); }
        ;

    Class : soul::cpp20::ast::Node*
        ::= CLASS{ return new soul::cpp20::ast::ClassNode(lexer.GetSourcePos(pos)); }
        ;

    TemplateId(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::TemplateIdNode> node, var std::unique_ptr<soul::cpp20::ast::Node> templateName, 
        var soul::ast::SourcePos sourcePos, var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : soul::cpp20::ast::Node*
        ::= 
        (
            (
                (   OperatorFunctionId(context):operatorFunctionId{ templateName.reset(operatorFunctionId); sourcePos = lexer.GetSourcePos(pos); }
                |   LiteralOperatorId(context):literalOperatorId{ templateName.reset(literalOperatorId); sourcePos = lexer.GetSourcePos(pos); }
                )
                LANGLE
                { 
                    laPos = lexer.GetSourcePos(pos); 
                    ++vars->langleCount; 
                    context->PushSetFlag(soul::cpp20::symbols::ContextFlags::parsingTemplateId); 
                    node.reset(new soul::cpp20::ast::TemplateIdNode(sourcePos, templateName.release())); 
                }
                TemplateArgumentList(context, node.get()):templateArgs?
                RANGLE
                { 
                    raPos = lexer.GetSourcePos(pos); 
                    --vars->langleCount; 
                    context->PopFlags(); 
                }
                / 
                { 
                    --vars->langleCount; 
                    context->PopFlags(); 
                }
            )
            {
                node->SetLAnglePos(laPos);
                node->SetRAnglePos(raPos);
                return node.release();
            }
        )
        |   SimpleTemplateId(context):simpleTemplateId{ return simpleTemplateId; }
        ;

    SimpleTemplateId(soul::cpp20::symbols::Context* context, var std::unique_ptr<soul::cpp20::ast::TemplateIdNode> node, var soul::ast::SourcePos sourcePos, 
        var soul::ast::SourcePos laPos, var soul::ast::SourcePos raPos) : soul::cpp20::ast::Node*
        ::= 
        (
            TemplateName(context):templateName{ sourcePos = lexer.GetSourcePos(pos); }
            LANGLE
            { 
                laPos = lexer.GetSourcePos(pos); 
                ++vars->langleCount; 
                context->PushSetFlag(soul::cpp20::symbols::ContextFlags::parsingTemplateId); 
                node.reset(new soul::cpp20::ast::TemplateIdNode(sourcePos, templateName)); 
            }
            TemplateArgumentList(context, node.get()):templateArgs?
            RANGLE
            { 
                raPos = lexer.GetSourcePos(pos); 
                --vars->langleCount; 
                context->PopFlags(); 
            }
            / 
            { 
                --vars->langleCount; 
                context->PopFlags(); 
            }
        )
        {
            node->SetLAnglePos(laPos);
            node->SetRAnglePos(raPos);
            return node.release();
        }
        ;

    TemplateName(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= Identifier(context):identifier{ return identifier; }
        ;

    TemplateArgumentList(soul::cpp20::symbols::Context* context, soul::cpp20::ast::Node* templateIdNode, var int index)
        ::= 
        (
            TemplateArgument(context, templateIdNode, index):left{ templateIdNode->AddNode(left); ++index; }
            (
                Comma:comma{ templateIdNode->AddNode(comma); } 
                TemplateArgument(context, templateIdNode, index):right{ templateIdNode->AddNode(right); ++index; }
            )*
        )
        (
            ELLIPSIS{ templateIdNode->AddNode(new soul::cpp20::ast::EllipsisNode(lexer.GetSourcePos(pos))); }
        )?
        ;

    TemplateArgument(soul::cpp20::symbols::Context* context, soul::cpp20::ast::Node* templateIdNode, int index) : soul::cpp20::ast::Node*
        ::= empty{ pass = soul::cpp20::symbols::TemplateArgCanBeTypeId(templateIdNode, index); } 
            TypeId(context):typeId 
            TemplateArgNext:next
            { 
                return typeId; 
            }
        |   ConstantExpression(context):constantExpr{ return constantExpr; }
        |   IdExpression(context):idExpr{ return idExpr; }
        ;

    TemplateArgNext
        ::= &(RANGLE | COMMA | ELLIPSIS)
        ;

    DeductionGuide(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= empty{ pass = false; }
        ;

    ExplicitInstantiation(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= empty{ pass = false; }
        ;

    ExplicitSpecialization(soul::cpp20::symbols::Context* context) : soul::cpp20::ast::Node*
        ::= empty{ pass = false; }
        ;

    Extern : soul::cpp20::ast::Node*
        ::= EXTERN{ return new soul::cpp20::ast::ExternNode(lexer.GetSourcePos(pos)); }
        ;

    Template : soul::cpp20::ast::Node*
        ::= TEMPLATE{ return new soul::cpp20::ast::TemplateNode(lexer.GetSourcePos(pos)); }
        ;

}