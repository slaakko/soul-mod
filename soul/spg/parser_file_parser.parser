// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

export module soul.spg.parser.file.parser;

[interface]import soul.ast.spg;
[implementation]import soul.cpp.token;
[implementation]import soul.cpp.op.token;
[implementation]import soul.punctuation.token;
[implementation]import soul.tool.token;
[implementation]import soul.common.common.parser;
[implementation]import soul.cpp.declarator.parser;
[implementation]import soul.cpp.statement.parser;
[implementation]import soul.cpp.expression.parser; 
[implementation]import soul.lex.spg;
[implementation]import soul.ast.cpp;
[implementation]import soul.spg.parsing.util;
[implementation]import soul.spg.token.parser;

parser ParserFileParser
{
    lexer soul::lex::spg::SpgLexer<char32_t>;

    main;
    using CommonParser.ExportModule;
    using CommonParser.Import;
    using CommonParser.QualifiedId;
    using CommonParser.ParserKeyword;
    using CommonParser.LexerKeyword;
    using DeclaratorParser.TypeId;
    using DeclaratorParser.Declarator;
    using StatementParser.CompoundStatement;
    using ExpressionParser.ExpressionList;

    ParserFile(var std::unique_ptr<soul::ast::spg::ParserFile> parserFile) : soul::ast::spg::ParserFile*
        ::= 
        (
            empty{ parserFile.reset(new soul::ast::spg::ParserFile(lexer.FileName())); }
            ExportModule:exportModuleDeclaration{ parserFile->SetExportModule(exportModuleDeclaration); }
            (Import:importDeclaration{ parserFile->AddImport(importDeclaration); })*
            (Parser:par{ parserFile->AddParser(par); })*
        )
        {
            return parserFile.release();
        }
        ;

    Parser(var std::unique_ptr<soul::ast::spg::GrammarParser> par) : soul::ast::spg::GrammarParser*
        ::= 
        (
            ParserKeyword:parserKeyword ID{ par.reset(new soul::ast::spg::GrammarParser(util::ToUtf8(lexer.GetToken(pos).ToString()))); }
            LBRACE! 
            ParserStatement(par.get()):statement*
            RBRACE!
        )
        {
            return par.release();
        }
        ;

    ParserStatement(soul::ast::spg::GrammarParser* par)
        ::= LexerStatement(par):lexerStatement
        |   MainStatement(par):mainStatement
        |   UsingStatement(par):usingStatement
        |   RuleStatement(par):ruleStatement
        ;

    LexerStatement(soul::ast::spg::GrammarParser* par)
        ::= LexerKeyword:lexerKeyword TypeId:lexerTypeId! SEMICOLON!{ par->AddLexer(lexerTypeId); }
        ;

    MainStatement(soul::ast::spg::GrammarParser* par)
        ::= MAIN SEMICOLON!{ par->SetMain(); }
        ;

    UsingStatement(soul::ast::spg::GrammarParser* par)
        ::= USING QualifiedId:parserRuleId! SEMICOLON!{ par->AddUsing(parserRuleId); }
        ;

    RuleStatement(soul::ast::spg::GrammarParser* par, var std::unique_ptr<soul::ast::spg::RuleParser> rule)
        ::= 
        (
            ID{ rule.reset(new soul::ast::spg::RuleParser(util::ToUtf8(lexer.GetToken(pos).ToString()))); }
            ParametersAndVariables(rule.get()):paramsAndVars?
            ReturnType:returnType?
            PRODUCES
            RuleBody:definition! 
            SEMICOLON!
        )
        {
            rule->SetDefinition(definition);
            rule->SetReturnType(returnType);
            par->AddRule(rule.release());
        }
        ;

    ParametersAndVariables(soul::ast::spg::RuleParser* rule)
        ::= LPAREN (ParamOrVariable:paramOrVariable{ rule->AddParamOrVariable(paramOrVariable); } % COMMA)? RPAREN!
        ;

    ParamOrVariable : soul::ast::spg::ParamVar*
        ::= VAR TypeId:varType Declarator:varName{ return new soul::ast::spg::Variable(varType, varName); }
        |   TypeId:paramType Declarator:paramName{ return new soul::ast::spg::Parameter(paramType, paramName); }
        ;

    ReturnType : soul::ast::cpp::TypeIdNode*
        ::= COLON TypeId:typeId{ return typeId; }
        ;

    RuleBody : soul::ast::spg::Parser*
        ::= Alternative:alt{ return alt; }
        ;

    Alternative(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::= 
        (
            Sequence:left{ value.reset(left); } 
            (
                PIPE Sequence:right!{ value.reset(new soul::ast::spg::AlternativeParser(value.release(), right)); }
            )*
        )
        {
            return value.release();
        }
        ;

    Sequence(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::=
        (
            Difference:left{ value.reset(left); }
            (
                Difference:right{ value.reset(new soul::ast::spg::SequenceParser(value.release(), right)); }
            )*
        )
        {
            return value.release();
        }
        ;

    Difference(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::=
        (
            List:left{ value.reset(left); }
            (
                MINUS List:right!{ value.reset(new soul::ast::spg::DifferenceParser(value.release(), right)); }
            )*
        )
        {
            return value.release();
        }
        ;

    List(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::=
        (
            Prefix:left{ value.reset(left); }
            (
                REM Prefix:right!{ value.reset(new soul::ast::spg::ListParser(value.release(), right)); }
            )?
        )
        {
            return value.release();
        }
        ;

    Prefix : soul::ast::spg::Parser*
        ::= AMP Postfix:lookaheadp{ return new soul::ast::spg::LookaheadParser(lookaheadp); }
        |   Postfix:postfix{ return postfix; }
        ;

    Postfix(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::= 
        (   Primary:primary{ value.reset(primary); }
            (   STAR{ value.reset(new soul::ast::spg::KleeneParser(value.release())); }
            |   PLUS{ value.reset(new soul::ast::spg::PositiveParser(value.release())); }
            |   QUEST{ value.reset(new soul::ast::spg::OptionalParser(value.release())); }
            )?
        )
        {
            return value.release();
        }
        ;

    Primary(var std::unique_ptr<soul::ast::spg::Parser> value) : soul::ast::spg::Parser*
        ::= 
        (
            (   RuleCall:ruleCall{ value.reset(ruleCall); }
            |   Primitive:primitive{ value.reset(primitive); }
            |   Grouping:grouping{ value.reset(grouping); }
            )
            (
                EXCLAMATION{ value.reset(new soul::ast::spg::ExpectationParser(value.release())); }
            )?
            (
                (
                    CompoundStatement:successCode
                    (
                        DIV CompoundStatement:failureCode
                    )?
                )
                {
                    value.reset(new soul::ast::spg::ActionParser(value.release(), successCode, failureCode));
                }
            )?
        )
        {
            return value.release();
        }
        ;

    RuleCall(var std::string ruleName, var int64_t nonterminalPos, var std::unique_ptr<soul::ast::cpp::ExprListNode> args) : soul::ast::spg::Parser*
        ::= 
        (
            Nonterminal:nt{ ruleName = nt; nonterminalPos = pos; }
            (   LPAREN{ pass = soul::lexer::NoWhiteSpaceBetweenTokens(lexer.GetToken(nonterminalPos), lexer.GetToken(pos)); args.reset(new soul::ast::cpp::ExprListNode()); }
                ExpressionList(args.get()):arguments 
                RPAREN
            )? 
            COLON 
            ID!
            {
                std::string instanceName = util::ToUtf8(lexer.GetToken(pos).ToString());
                return new soul::ast::spg::NonterminalParser(ruleName, instanceName, args.release());
            }
        )
        ;

    Nonterminal : std::string
        ::= 
        (
            ID{ return util::ToUtf8(lexer.GetToken(pos).ToString()); }
        )
        ;

    Primitive : soul::ast::spg::Parser*
        ::= 
        (   EMPTY{ return new soul::ast::spg::EmptyParser(); }
        |   ANY{ return new soul::ast::spg::AnyParser(); }
        |   ID{ return new soul::ast::spg::TokenParser(util::ToUtf8(lexer.GetToken(pos).ToString())); }
        |   CHAR_LITERAL{ return new soul::ast::spg::CharParser(soul::spg::token::parser::ParseCharLiteral(lexer.FileName(), lexer.GetToken(pos))); }
        |   STRING_LITERAL
            { 
                std::u32string str = soul::spg::token::parser::ParseStringLiteral(lexer.FileName(), lexer.GetToken(pos)); 
                return soul::spg::parsing::util::MakeParserFromStrLiteral(str); 
            }
        )
        ;

    Grouping : soul::ast::spg::Parser*
        ::= 
        (
            LPAREN 
            Alternative:alt
            RPAREN!
        )
        {
            return new soul::ast::spg::GroupingParser(alt);
        }
        ;
}
